
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module lab12(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT
);



//=======================================================
//  REG/WIRE declarations 1
//=======================================================

wire reset = SW[1];
wire [9:0] ha;
wire [9:0] va;
reg [23:0] vgadata;
wire [23:0] vgadata1;
wire [23:0] vgadata2;
wire ready1;
wire ready2;
wire wr_ready1;
wire wr_ready2;
wire dele_wren1;
wire dele_wren2;
wire data_wren1;
wire data_wren2;
wire [10:0] off1;
wire [10:0] off2;
wire [9:0] wr_iter1;
wire [9:0] wr_iter2;
wire [7:0] kb_data;
wire kb_ready;
wire kb_real_ready;
wire [7:0] vmdata_wr; //asciicode
wire [5:0] vmdata_wraddr; //position
wire wr_line; //linenum
wire [7:0] veldata_wr; //velocity
wire [13:0] hit_count1;
wire [13:0] hit_count2;
wire [13:0] hit_count;
wire video_mem_reset;
wire v_end;
wire [13:0] miss_count1;
wire [13:0] miss_count2;
wire [13:0] miss_count;

//=======================================================
//  REG/WIRE declarations 2
//=======================================================

wire [9:0] h_addr1;
wire [9:0] v_addr1;
wire [3:0] h_addr3;
wire [3:0] v_addr3;

wire [13:0] presscount;
wire [7:0] info_ascii;

assign h_addr1=ha/9;
assign v_addr1=va/16;
assign h_addr3=h_addr1-57;
assign v_addr3=v_addr1-8;

wire [7:0] addr;
assign addr=v_addr3*12+h_addr3;

wire initiate_black;
wire game_info_black;
wire gameover_info_black;

wire menu_or_game;
wire [1:0] mode;
wire start;

wire [23:0] vgadata_game;

wire [13:0] count_time;
wire end_game;

wire clk_lit;
wire clk_blink;
reg [23:0] font_lit;
reg [7:0] font_blink;
reg up_or_down; //1 means up and 0 means down
reg up_or_down1;

wire clk_timeup;
wire clk_score;
wire clk_round;

reg [1:0] gameovercolor;
reg [5:0] gameoverround;

initial
begin
	font_lit=16777215;
	font_blink=0;
	up_or_down=0;
	up_or_down1=1;
	gameovercolor=0;
	gameoverround=9;
end

//=======================================================
//  Structural coding
//=======================================================


clkgen #(25000000) my_vgaclk(CLOCK_50,reset,1'b1,VGA_CLK);

clkgen #(300) clk_ini1(CLOCK_50,reset,1'b1,clk_lit);

clkgen #(200) clk_ini2(CLOCK_50,reset,1'b1,clk_blink);

clkgen #(10) gameover(CLOCK_50,reset,1'b1,clk_round); 

clkgen #(5) timeup(CLOCK_50,reset,1'b1,clk_timeup);

clkgen #(2) score(CLOCK_50,reset,1'b1,clk_score);



vga_ctrl	my_vga(VGA_CLK,reset,vgadata,ha,va,VGA_HS,VGA_VS,VGA_BLANK_N,VGA_R,VGA_G,VGA_B,v_end);

new_assign_vgadata assign_my_vgadata1(CLOCK_50, VGA_CLK, ha, va, vgadata1, VGA_BLANK_N, start & ~end_game, ready1, 1, 
											kb_real_ready, dele_wren1, kb_data, off1, wr_iter1,
											vmdata_wr, data_wren1, vmdata_wraddr, wr_ready1, veldata_wr, hit_count1, video_mem_reset, v_end, miss_count1, mode);
											
new_assign_vgadata assign_my_vgadata2(CLOCK_50, VGA_CLK, ha, va, vgadata2, VGA_BLANK_N, start & ~end_game, ready2, 2, 
											kb_real_ready, dele_wren2, kb_data, off2, wr_iter2,
											vmdata_wr, data_wren2, vmdata_wraddr, wr_ready2, veldata_wr, hit_count2, video_mem_reset, v_end, miss_count2, mode);

switch_interface func1(
	.interface(KEY[1]),
	.start_or_stop(KEY[0]),
	.choose_mode(KEY[2]),
	.reset(reset),
	.menu_or_game(menu_or_game),
	.mode(mode),
	.start(start)
);


ps2_keyboard func2(
	.clk(CLOCK_50),
	.ps2_clk(PS2_CLK),
	.ps2_data(PS2_DAT),
	.clrn(~KEY[1]),
	.start(start&&(~end_game)),
	.mode(mode),
	.ready(kb_ready),
	.asciicode(kb_data),
	.presscount(presscount),
	.real_ready(kb_real_ready)
);

LFSR func3(
	.clk(VGA_CLK),
	.en(~menu_or_game),
	.mode(mode),
	.seed(32'h6A09E667),
	.velocity_port(veldata_wr)
);

LFSR func4(
	.clk(VGA_CLK),
	.en(~menu_or_game),
	.mode(mode),
	.seed(32'h3C6EF372),
	.position_port(vmdata_wraddr)
);

LFSR func5(
	.clk(VGA_CLK),
	.en(~menu_or_game),
	.mode(mode),
	.seed(32'h9B05688C),
	.asciicode_port(vmdata_wr)
);

LFSR func6(
	.clk(VGA_CLK),
	.en(~menu_or_game),
	.mode(mode),
	.seed(32'h1F83D9AB),
	.linenum_port(wr_line)
);

info_frame func7(
	.clk(CLOCK_50),
	.reset(~KEY[1]),
	.start(start),
	.end_game(end_game),
	.presscount(presscount),
	.score(hit_count),
	.addr(addr),
	.count_time(count_time),
	.misscount(miss_count),
	.mode(mode),
	.info_ascii(info_ascii)
);

numToled func8(
	.count(kb_data/16),
	.ready(kb_ready),
	.led(HEX1)
);

numToled func9(
	.count(kb_data%16),
	.ready(kb_ready),
	.led(HEX0)
);

countdown func10(
	.clk(VGA_CLK),
	.menu_or_game(menu_or_game),
	.start(start),
	.mode(mode),
	.count_time(count_time),
	.end_game(end_game)
);


interface_vga_transit(
	.clk(CLOCK_50),
	.menu_or_game(menu_or_game),
	.h_addr(ha),
	.v_addr(va),
	.game_info_ascii(info_ascii),
	.initiate_black(initiate_black),
	.game_info_black(game_info_black),
	.gameover_info_black(gameover_info_black)
);

always @ (posedge CLOCK_50)
begin
	if(menu_or_game==1)
	begin
		if(v_addr1>=2&&v_addr1<=17&&initiate_black&&ha<=630)
		begin
			vgadata<={font_lit[15:0],font_lit[23:16]};
		end
		
		else if(v_addr1==20&&initiate_black&&ha<=630)
		begin
			vgadata<=24'h32CD32;
		end
		
		else if(v_addr1==25&&initiate_black&&ha<=630)
		begin
			vgadata<={font_blink,font_blink,font_blink};
		end
		
		else
		begin
		if(mode==2'b00)
		begin
			if(initiate_black&&ha<=630)
			begin
				if(v_addr1==21&&h_addr1>24&&h_addr1<45)
					vgadata<=24'hFF8C00;
				else
					vgadata<=24'hBEBEBE;
			end
			else
				vgadata<=24'h000000;
		end
		else if(mode==2'b01)
		begin
			if(initiate_black&&ha<=630)
			begin
				if(v_addr1==22&&h_addr1>24&&h_addr1<45)
					vgadata<=24'hFF8C00;
				else
					vgadata<=24'hBEBEBE;
			end
			else
				vgadata<=24'h000000;
		end
		else if(mode==2'b10)
		begin
			if(initiate_black&&ha<=630)
			begin
				if(v_addr1==23&&h_addr1>24&&h_addr1<45)
					vgadata<=24'hFF8C00;
				else
					vgadata<=24'hBEBEBE;
			end
			else
				vgadata<=24'h000000;
		end
		end
	end
	else
	begin
		if(h_addr1>=1&&h_addr1<=53)
		begin
			if(end_game==0)
				vgadata<=vgadata_game;
			else
			begin
				if(gameover_info_black==1)
				begin
					if(v_addr1<24)
					begin
						if(gameovercolor==0)
							vgadata<=24'hFFD700;
						else if(gameovercolor==1)
							vgadata<=24'h00FF7F;
						else if(gameovercolor==2)
							vgadata<=24'h00BFFF;
						else
							vgadata<=24'hFF4500;
					end
					else
					begin
						if(h_addr1==gameoverround)
							vgadata<=24'hFFD700;
						else
							vgadata<=24'h6A5ACD;
					end
				end
				else
					vgadata<=24'h1C1C1C;
			end
		end
		
		else if(h_addr1>=57&&h_addr1<=68&&v_addr1>=8&&v_addr1<=22&&game_info_black)
		begin
			if(v_addr1==9&&h_addr1>57&&h_addr1<68)
				vgadata<=24'h32CD32;
			else if(v_addr1>=11&&v_addr1<=16&&h_addr1>57&&h_addr1<68&&end_game==1)
			begin
				if(clk_score==1)
					vgadata<=24'h000000;
				else
					vgadata<=24'hFFFFFF;
			end
			else if(v_addr1==17&&h_addr1>57&&h_addr1<68)
				vgadata<=24'h0000FF;
			else if(v_addr1==18&&h_addr1>57&&h_addr1<68)
			begin
				if(mode==2'b00||mode==2'b01)
				begin
					if(count_time<=10&&count_time>0&&clk_timeup==1&&start)
						vgadata<=24'hFF0000;
					else
						vgadata<=24'h0000FF;
				end
				else
					vgadata<=24'h0000FF;
			end
			else if(v_addr1==19&&h_addr1>57&&h_addr1<68)//time up
				vgadata<=24'hFF0000;
			else if(v_addr1==20&&h_addr1>57&&h_addr1<68)//paused
				vgadata<=24'h00FFFF;
			else if(v_addr1==21&&h_addr1>57&&h_addr1<68)//ama pro edl
				vgadata<=24'h008B8B;
			else
				vgadata<=24'hFFE7BA;
		end
			
		else
			vgadata<=24'h8B4513;
			
	end
end

always @ (posedge clk_lit)
begin
	if(font_lit==16777214)
		up_or_down<=0;
	else if(font_lit==1)
		up_or_down<=1;
	if(up_or_down==1)
		font_lit<=font_lit+1;
	else
		font_lit<=font_lit-1;
end

always @ (posedge clk_blink)
begin
	if(font_blink==254)
		up_or_down1<=0;
	else if(font_blink==1)
		up_or_down1<=1;
	if(up_or_down1==1)
		font_blink<=font_blink+1;
	else
		font_blink<=font_blink-1;
end

always @ (posedge clk_score)
begin
	gameovercolor<=gameovercolor+1;
end

always @ (posedge clk_round)
begin
	if(gameoverround==41)
		gameoverround<=9;
	else if(gameoverround==13||gameoverround==20||gameoverround==23||gameoverround==28||gameoverround==31||gameoverround==36)
		gameoverround<=gameoverround+2;
	else
		gameoverround<=gameoverround+1;
end

assign VGA_SYNC_N = 1'b0;
assign vgadata_game = (ready1) ? vgadata1 : vgadata2;

assign dele_wren1 = (((off1 - 32 < off2 - 32) || wr_iter2 == 0) && wr_iter1 != 0 && kb_ready) ? 1 : 0;
assign dele_wren2 = (((off1 - 32 >= off2 - 32) || wr_iter1 == 0) && wr_iter2 != 0 && kb_ready) ? 1 : 0;

assign data_wren1 = ~wr_line & wr_ready1 & start;
assign data_wren2 = wr_line & wr_ready2 & start;

assign LEDR[0] = kb_ready;
assign LEDR[1] = dele_wren1;
assign LEDR[2] = dele_wren2;
assign LEDR[3] = wr_ready1;
assign LEDR[4] = wr_ready2; 
assign LEDR[5] = kb_real_ready;
assign LEDR[6] = end_game;

assign video_mem_reset = ~KEY[1];
assign hit_count = hit_count1 + hit_count2;
assign miss_count = miss_count1 + miss_count2;

endmodule
